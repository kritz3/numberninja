<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>Snake</title>
  <style>
    :root {
      --bg: #0b1220;
      --card: #111a2e;
      --text: #eaf0ff;
      --muted: #9fb0d0;
      --good: #2dd4bf;
      --bad: #fb7185;
      --warn: #fbbf24;
      --btn: #1f2a44;
      --btnHover: #283658;
      --shadow: rgba(0,0,0,0.35);
      --snake: #2dd4bf;
      --food: #fb7185;
    }

    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      background: radial-gradient(1200px 800px at 20% 10%, #1a2a55 0%, var(--bg) 55%);
      color: var(--text);
      min-height: 100vh;
      min-height: 100dvh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 16px;
      overflow: hidden;
      touch-action: none;
    }

    .wrap {
      width: min(400px, 100%);
      display: grid;
      gap: 14px;
    }

    .topbar {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    .pill {
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 14px;
      padding: 12px 14px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      box-shadow: 0 10px 30px var(--shadow);
      backdrop-filter: blur(6px);
    }
    .pill .label { color: var(--muted); font-size: 12px; }
    .pill .value { font-size: 18px; font-weight: 700; }

    .card {
      background: rgba(17,26,46,0.82);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 18px;
      padding: 18px;
      box-shadow: 0 14px 40px var(--shadow);
      backdrop-filter: blur(8px);
    }

    .game-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 14px;
    }

    canvas {
      border-radius: 12px;
      background: #0a0f1a;
      box-shadow: inset 0 0 20px rgba(0,0,0,0.5);
    }

    .controls {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center;
    }

    button.primary, button.secondary {
      appearance: none;
      border: 1px solid rgba(255,255,255,0.12);
      background: var(--btn);
      color: var(--text);
      border-radius: 14px;
      padding: 14px 20px;
      font-size: 16px;
      font-weight: 700;
      cursor: pointer;
      box-shadow: 0 10px 22px rgba(0,0,0,0.25);
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }
    button.primary:active, button.secondary:active { transform: scale(0.98); }
    button.primary:hover, button.secondary:hover { background: var(--btnHover); }
    button.primary {
      background: rgba(45,212,191,0.18);
      border-color: rgba(45,212,191,0.35);
    }
    button.primary:hover { background: rgba(45,212,191,0.25); }

    /* D-pad for mobile */
    .dpad {
      display: grid;
      grid-template-areas:
        ". up ."
        "left . right"
        ". down .";
      grid-template-columns: repeat(3, 60px);
      grid-template-rows: repeat(3, 50px);
      gap: 6px;
      margin-top: 10px;
    }
    .dpad button {
      appearance: none;
      border: 1px solid rgba(255,255,255,0.15);
      background: var(--btn);
      color: var(--text);
      border-radius: 12px;
      font-size: 20px;
      cursor: pointer;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .dpad button:active { background: var(--btnHover); transform: scale(0.95); }
    .dpad-up { grid-area: up; }
    .dpad-down { grid-area: down; }
    .dpad-left { grid-area: left; }
    .dpad-right { grid-area: right; }

    .message {
      text-align: center;
      font-size: 14px;
      color: var(--muted);
      min-height: 20px;
    }

    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.7);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 16px;
      border-radius: 12px;
    }
    .overlay.hidden { display: none; }
    .overlay-title {
      font-size: 28px;
      font-weight: 900;
    }
    .overlay-score {
      font-size: 18px;
      color: var(--muted);
    }

    .game-wrapper {
      position: relative;
      display: inline-block;
    }

    .speed-selector {
      display: flex;
      gap: 8px;
      justify-content: center;
      margin-bottom: 10px;
    }
    .speed-selector button {
      padding: 8px 14px;
      font-size: 13px;
      font-weight: 600;
      background: rgba(255,255,255,0.04);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 10px;
      color: var(--muted);
      cursor: pointer;
      touch-action: manipulation;
    }
    .speed-selector button.active {
      background: rgba(45,212,191,0.15);
      border-color: rgba(45,212,191,0.3);
      color: var(--good);
    }

    .footer {
      text-align: center;
      color: var(--muted);
      font-size: 12px;
    }

    @media (min-width: 500px) {
      .dpad { display: none; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div class="pill">
        <div>
          <div class="label">Score</div>
          <div class="value" id="score">0</div>
        </div>
      </div>
      <div class="pill">
        <div>
          <div class="label">Best</div>
          <div class="value" id="best">0</div>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="game-container">
        <div class="speed-selector" id="speedSelector">
          <button data-speed="slow">Slow</button>
          <button data-speed="normal" class="active">Normal</button>
          <button data-speed="fast">Fast</button>
        </div>

        <div class="speed-selector" id="wallToggle">
          <button data-walls="solid" class="active">Solid Walls</button>
          <button data-walls="wrap">Pass Through</button>
        </div>

        <div class="game-wrapper">
          <canvas id="game" width="320" height="320"></canvas>
          <div class="overlay" id="overlay">
            <div class="overlay-title" id="overlayTitle">Snake</div>
            <div class="overlay-score" id="overlayScore">Use arrow keys or swipe to move</div>
            <button class="primary" id="startBtn">Play</button>
          </div>
        </div>

        <div class="message" id="message">Arrow keys / WASD / Swipe to move</div>

        <div class="dpad" id="dpad">
          <button class="dpad-up" data-dir="up">&#9650;</button>
          <button class="dpad-left" data-dir="left">&#9664;</button>
          <button class="dpad-right" data-dir="right">&#9654;</button>
          <button class="dpad-down" data-dir="down">&#9660;</button>
        </div>
      </div>
    </div>

    <div class="footer">
      <a href="index.html" style="color:var(--good); text-decoration:none;">Back to Number Ninja</a>
    </div>
  </div>

  <script>
    // ---------- Constants ----------
    const GRID_SIZE = 20;
    const CELL_SIZE = 16;
    const CANVAS_SIZE = GRID_SIZE * CELL_SIZE;

    const SPEEDS = {
      slow: 150,
      normal: 100,
      fast: 60,
    };

    // ---------- State ----------
    const state = {
      snake: [],
      direction: { x: 1, y: 0 },
      nextDirection: { x: 1, y: 0 },
      food: { x: 0, y: 0 },
      score: 0,
      best: 0,
      running: false,
      gameOver: false,
      speed: "normal",
      wallWrap: false,
      loopId: null,
    };

    // ---------- Elements ----------
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const elScore = document.getElementById("score");
    const elBest = document.getElementById("best");
    const elMessage = document.getElementById("message");
    const overlay = document.getElementById("overlay");
    const overlayTitle = document.getElementById("overlayTitle");
    const overlayScore = document.getElementById("overlayScore");
    const startBtn = document.getElementById("startBtn");
    const speedSelector = document.getElementById("speedSelector");
    const dpad = document.getElementById("dpad");

    // ---------- Storage ----------
    const BEST_KEY = "snake_best_v1";

    function loadBest() {
      const saved = Number(localStorage.getItem(BEST_KEY));
      state.best = Number.isFinite(saved) ? saved : 0;
      elBest.textContent = String(state.best);
    }

    function saveBest() {
      if (state.score > state.best) {
        state.best = state.score;
        localStorage.setItem(BEST_KEY, String(state.best));
        elBest.textContent = String(state.best);
      }
    }

    // ---------- Game Logic ----------
    function initGame() {
      // Start snake in the middle
      const startX = Math.floor(GRID_SIZE / 2);
      const startY = Math.floor(GRID_SIZE / 2);
      state.snake = [
        { x: startX, y: startY },
        { x: startX - 1, y: startY },
        { x: startX - 2, y: startY },
      ];
      state.direction = { x: 1, y: 0 };
      state.nextDirection = { x: 1, y: 0 };
      state.score = 0;
      state.gameOver = false;
      elScore.textContent = "0";
      placeFood();
    }

    function placeFood() {
      let attempts = 0;
      while (attempts < 1000) {
        const x = Math.floor(Math.random() * GRID_SIZE);
        const y = Math.floor(Math.random() * GRID_SIZE);
        const onSnake = state.snake.some(seg => seg.x === x && seg.y === y);
        if (!onSnake) {
          state.food = { x, y };
          return;
        }
        attempts++;
      }
    }

    function update() {
      if (state.gameOver) return;

      // Apply queued direction
      state.direction = { ...state.nextDirection };

      // Calculate new head position
      const head = state.snake[0];
      const newHead = {
        x: head.x + state.direction.x,
        y: head.y + state.direction.y,
      };

      // Check wall collision or wrap
      if (newHead.x < 0 || newHead.x >= GRID_SIZE || newHead.y < 0 || newHead.y >= GRID_SIZE) {
        if (state.wallWrap) {
          // Wrap around
          if (newHead.x < 0) newHead.x = GRID_SIZE - 1;
          if (newHead.x >= GRID_SIZE) newHead.x = 0;
          if (newHead.y < 0) newHead.y = GRID_SIZE - 1;
          if (newHead.y >= GRID_SIZE) newHead.y = 0;
        } else {
          endGame();
          return;
        }
      }

      // Check self collision
      if (state.snake.some(seg => seg.x === newHead.x && seg.y === newHead.y)) {
        endGame();
        return;
      }

      // Add new head
      state.snake.unshift(newHead);

      // Check food collision
      if (newHead.x === state.food.x && newHead.y === state.food.y) {
        state.score++;
        elScore.textContent = String(state.score);
        placeFood();
      } else {
        // Remove tail if no food eaten
        state.snake.pop();
      }
    }

    function draw() {
      // Clear canvas
      ctx.fillStyle = "#0a0f1a";
      ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

      // Draw grid (subtle)
      ctx.strokeStyle = "rgba(255,255,255,0.03)";
      ctx.lineWidth = 1;
      for (let i = 0; i <= GRID_SIZE; i++) {
        ctx.beginPath();
        ctx.moveTo(i * CELL_SIZE, 0);
        ctx.lineTo(i * CELL_SIZE, CANVAS_SIZE);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(0, i * CELL_SIZE);
        ctx.lineTo(CANVAS_SIZE, i * CELL_SIZE);
        ctx.stroke();
      }

      // Draw food
      ctx.fillStyle = "#fb7185";
      ctx.beginPath();
      ctx.arc(
        state.food.x * CELL_SIZE + CELL_SIZE / 2,
        state.food.y * CELL_SIZE + CELL_SIZE / 2,
        CELL_SIZE / 2 - 2,
        0,
        Math.PI * 2
      );
      ctx.fill();

      // Draw snake
      state.snake.forEach((seg, i) => {
        const isHead = i === 0;
        const brightness = 1 - (i / state.snake.length) * 0.4;

        if (isHead) {
          ctx.fillStyle = "#2dd4bf";
        } else {
          ctx.fillStyle = `rgba(45, 212, 191, ${brightness})`;
        }

        const padding = isHead ? 1 : 2;
        ctx.beginPath();
        ctx.roundRect(
          seg.x * CELL_SIZE + padding,
          seg.y * CELL_SIZE + padding,
          CELL_SIZE - padding * 2,
          CELL_SIZE - padding * 2,
          4
        );
        ctx.fill();

        // Draw eyes on head
        if (isHead) {
          ctx.fillStyle = "#0a0f1a";
          const eyeSize = 3;
          const eyeOffset = 4;

          let eye1x, eye1y, eye2x, eye2y;
          const cx = seg.x * CELL_SIZE + CELL_SIZE / 2;
          const cy = seg.y * CELL_SIZE + CELL_SIZE / 2;

          if (state.direction.x === 1) {
            eye1x = cx + 2; eye1y = cy - eyeOffset;
            eye2x = cx + 2; eye2y = cy + eyeOffset;
          } else if (state.direction.x === -1) {
            eye1x = cx - 2; eye1y = cy - eyeOffset;
            eye2x = cx - 2; eye2y = cy + eyeOffset;
          } else if (state.direction.y === 1) {
            eye1x = cx - eyeOffset; eye1y = cy + 2;
            eye2x = cx + eyeOffset; eye2y = cy + 2;
          } else {
            eye1x = cx - eyeOffset; eye1y = cy - 2;
            eye2x = cx + eyeOffset; eye2y = cy - 2;
          }

          ctx.beginPath();
          ctx.arc(eye1x, eye1y, eyeSize, 0, Math.PI * 2);
          ctx.arc(eye2x, eye2y, eyeSize, 0, Math.PI * 2);
          ctx.fill();
        }
      });
    }

    function gameLoop() {
      if (!state.running) return;

      update();
      draw();

      if (!state.gameOver) {
        state.loopId = setTimeout(gameLoop, SPEEDS[state.speed]);
      }
    }

    function startGame() {
      initGame();
      state.running = true;
      overlay.classList.add("hidden");
      elMessage.textContent = "Arrow keys / WASD / Swipe to move";
      speedSelector.style.display = "none";
      wallToggle.style.display = "none";
      draw();
      gameLoop();
    }

    function endGame() {
      state.gameOver = true;
      state.running = false;
      clearTimeout(state.loopId);
      saveBest();

      overlayTitle.textContent = "Game Over";
      overlayScore.textContent = `Score: ${state.score}`;
      startBtn.textContent = "Play Again";
      overlay.classList.remove("hidden");
      speedSelector.style.display = "flex";
      wallToggle.style.display = "flex";
    }

    // ---------- Input Handling ----------
    function setDirection(dir) {
      if (!state.running || state.gameOver) return;

      const { x, y } = state.direction;

      switch (dir) {
        case "up":
          if (y !== 1) state.nextDirection = { x: 0, y: -1 };
          break;
        case "down":
          if (y !== -1) state.nextDirection = { x: 0, y: 1 };
          break;
        case "left":
          if (x !== 1) state.nextDirection = { x: -1, y: 0 };
          break;
        case "right":
          if (x !== -1) state.nextDirection = { x: 1, y: 0 };
          break;
      }
    }

    // Keyboard
    document.addEventListener("keydown", (e) => {
      if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "w", "a", "s", "d"].includes(e.key)) {
        e.preventDefault();
      }

      switch (e.key) {
        case "ArrowUp":
        case "w":
        case "W":
          setDirection("up");
          break;
        case "ArrowDown":
        case "s":
        case "S":
          setDirection("down");
          break;
        case "ArrowLeft":
        case "a":
        case "A":
          setDirection("left");
          break;
        case "ArrowRight":
        case "d":
        case "D":
          setDirection("right");
          break;
        case " ":
          if (!state.running) startGame();
          break;
      }
    });

    // D-pad buttons
    dpad.querySelectorAll("button").forEach(btn => {
      btn.addEventListener("click", () => {
        setDirection(btn.dataset.dir);
      });
    });

    // Touch swipe
    let touchStartX = 0;
    let touchStartY = 0;

    document.addEventListener("touchstart", (e) => {
      touchStartX = e.touches[0].clientX;
      touchStartY = e.touches[0].clientY;
    }, { passive: true });

    document.addEventListener("touchend", (e) => {
      if (!state.running) return;

      const touchEndX = e.changedTouches[0].clientX;
      const touchEndY = e.changedTouches[0].clientY;

      const dx = touchEndX - touchStartX;
      const dy = touchEndY - touchStartY;

      const minSwipe = 30;

      if (Math.abs(dx) > Math.abs(dy)) {
        if (dx > minSwipe) setDirection("right");
        else if (dx < -minSwipe) setDirection("left");
      } else {
        if (dy > minSwipe) setDirection("down");
        else if (dy < -minSwipe) setDirection("up");
      }
    }, { passive: true });

    // Speed selector
    speedSelector.querySelectorAll("button").forEach(btn => {
      btn.addEventListener("click", () => {
        speedSelector.querySelectorAll("button").forEach(b => b.classList.remove("active"));
        btn.classList.add("active");
        state.speed = btn.dataset.speed;
      });
    });

    // Wall toggle
    const wallToggle = document.getElementById("wallToggle");
    wallToggle.querySelectorAll("button").forEach(btn => {
      btn.addEventListener("click", () => {
        wallToggle.querySelectorAll("button").forEach(b => b.classList.remove("active"));
        btn.classList.add("active");
        state.wallWrap = btn.dataset.walls === "wrap";
      });
    });

    // Start button
    startBtn.addEventListener("click", startGame);

    // ---------- Init ----------
    loadBest();
    initGame();
    draw();
  </script>
</body>
</html>
